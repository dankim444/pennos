# PennOS
PennOS is a UNIX-like operating system simulator built to run as a single process on a host OS. Its main features include a priority-based scheduler that handles threads using the spthread module, a custom FAT-like file system, and a shell with support for job control, system calls, and user-level programs. Though it doesn't boot on actual hardware, our PennOS simulates real OS abstractions like kernel vs. user land, process/thread management, and file handling.

## Members (Name and Pennkey)
- Dan Kim (pennkey: dankim1)
- Kevin Zhou (pennkey: kzhou1)
- Krystof Purtell (pennkey: krystofp)
- Richard Zhang (pennkey: richz)

## List of Submitted Files
- Makefile
- Companion Document
- doc/README.md
- src/fs/fat_routines.c
- src/fs/fat_routines.h
- src/fs/fs_helpers.c
- src/fs/fs_helpers.h
- src/fs/fs_kfuncs.c
- src/fs/fs_kfuncs.h
- src/fs/fs_syscalls.c
- src/fs/fs_syscalls.h
- src/kernel/kern_pcb.c
- src/kernel/kern_pcb.h
- src/kernel/kern_sys_calls.c
- src/kernel/kern_sys_calls.h
- src/kernel/logger.c
- src/kernel/logger.h
- src/kernel/scheduler.c
- src/kernel/scheduler.h
- src/kernel/signal.c
- src/kernel/signal.h
- src/kernel/stress.c
- src/kernel/stress.h
- src/lib/pennos-errno.c
- src/lib/pennos-errno.h
- src/lib/spthread.c
- src/lib/spthread.h
- src/lib/Vec.c
- src/lib/Vec.h
- src/shell/builtins.c
- src/shell/builtins.h
- src/shell/Job.h
- src/shell/parser.c
- src/shell/parser.h
- src/shell/shell_built_ins.c
- src/shell/shell_built_ins.h
- src/shell/shell.c
- src/shell/shell.h
- src/pennfat.c
- src/pennos.c

## Extra Credit Implemented
- Compaction of directory files (extra credit 1)
- Free memory leaks (run valgrind for pennfat)

## Compilation Instructions
- `make` or `make all`: create executables of mains in src/
- `make tests`: create executables of test mains in tests/
- `make info`: list which files are set as main, execs, etc.
- `make format`: auto format main, test main, src, and header files
- `make clean`: delete *.o and executable files

## How to Run
- Run PennFAT standalone
```
./bin/pennfat
```
- Run PennOS
```
./bin/pennos [filesystem] [logfile]
```

## Overview of Work Accomplished

### PennFAT File System
The standalone PennFAT provides an interface for creating, mounting, and unmounting a filesystem as well as running various routines such as `cp`, `cat`, `ls`, `touch`, `rm`, `mv`, and `chmod`. 
- **The standalone PennFAT**
    - Runs as a continuous loop, prompting user for input, parsing the arguments, and executing the corresponding command.
    - Implements signal handling to properly respond to Ctrl-C and Ctrl-Z signals.
- **Filesystem regions**
    - *FAT region*: Stores the File Allocation Table which tracks block allocation and file chains.
    - *Data region*: Contains the root directory and all file data.
    - The first FAT entry stores filesystem metadata (block size and FAT size).
    - Block 1 is always reserved for the root directory. Note, files and directories can span multiple blocks.
    - Allocation and mapping of fat region is taken care of in `mkfs` and `mount`
- **Core Data Structures**
    - *Directory entry structure*: Stores file metadata including name, size, first block, type, permissions, and modification time.
    - *File descriptor entry structure*: Holds metadata about each file descriptor in the system-wide file descriptor table. Tracks open file state including position (indicates where subsequent reads or writes should take place), access mode, and reference counts.
- **File Descriptor Management**
    - Maintains a system-wide file descriptor table to track all open files.
    - Reserves standard file descriptors (0, 1, 2) for stdin, stdout, and stderr.
    - Enforces access restrictions (only one process can write to a file at a time).
    - Maintains proper open file reference counting.
- **Block Allocation and Directory Management**
    - Adds logic for finding files in a root directory and writing file entries to the filesystem.
    - Allocates new blocks as directories or files grow.
    - De-allocates old blocks as files or directories are truncated or deleted.
- **Abstraction**
    - System call functions (s_ functions) are wrappers around kernel functions to provide an interface for user programs.
    - Kernel-level functions (k_ functions) implement core filesystem operations such as k_open, k_close, k_read, k_write, k_lseek, k_unlink, and k_ls.
    - Process control blocks maintain per-process file descriptor tables.
    - Note: the only time we use regular system calls (ie. `read`, `lseek`, `write`, etc.) is when we interact with the host OS. For example, in `cp SOURCE -h DEST` we use `k_open()` to open `SOURCE` but `open()` to open `DEST`. However, in `cat` we only use the kernel-level functions we implemented. We use `lseek` and `write` to write to a file in the host OS.
- **Summary of Core Features**
    - *Basic file operations*: open, read, write, close, unlink, lseek
    - *File manipulation utilities*: cat, ls, touch, mv, cp, rm
    - *Filesystem management*: mkfs, mount, unmount

### Kernel
The PennOS kernel provides a thread scheduler and process management system that simulates a real operating system's functionality while running as a single process on the host OS.
- **Process Management**
    - *Process Control Block (PCB)*: Tracks a process state including the thread handle, pid, parent pid, children processes, priority level, process state, signals, and file descriptors, sleeping status, and wake up time.
    - Creates and deletes processes, while also managing resources.
    - Inherits properties of parent process and tracks parent-child relationships.
    - Reparents orphaned child processes to INIT.
    - Handles file desciptors.
    - Properly schedules new processes in corresponding queues.
    - Manages and reaps zombie children.
- **Signal Handling and Process States**
    - Defines 3 signals: P_SIGSTOP, P_SIGCONT, and P_SIGTERM
    - Supports macros P_WIFEXITED, P_WIFSTOPPED, P_WIFSIGNALED based on status definitions
- **System Calls**
    - *Process creation*: s_spawn and child process spawning
    - *Process control*: s_waitpid, s_kill, s_exit
    - *Scheduler interaction*: s_nice, s_sleep
- **Priority-based Scheduler**
    - Implements three priority levels (0, 1, 2) `zero_priority_queue`, `one_priority_queue`, and `two_priority_queue`.
    - Uses round-robin scheduling within each priority level.
    - Supports time-sliced execution with 100ms quanta.
    - Handles blocked, stopped, and sleeping processes.
- **Clock Ticks and Timing**
    - Implemented system clock implementation using SIGALRM
- **Idling**
    - Manages CPU usage when no processes are runnable
    - Implements sigsuspend
- **Logging**
    - Implements event logging for debugging and verification with timestamps

### Shell
The PennOS shell provides a user interface to interact with the simulated operating system, offering a set of built-in commands and job control features.
- **CLI**
    - Prompts user for command and parses arguments
    - Supports redirection
    - Supports fg/bg jobs
    - Handles signals for user interrupts
- **Built-in commands**
    - For files: cat, ls, touch, mv, cp, rm, chmod
    - For processes: ps, kill, nice, nice_pid
    - For jobs: bg, fg, jobs
    - For utilities: sleep, busy, echo, man
    - For testing utils: zombify, orphanify
    - System control: logout
- **Process hierarchy**
    - Shell as parent of user commands
    - Child process spawning and monitoring
    - Zombie reaping and cleanup
- **Script support**
    - Enables running of simple shell scripts
    - Checks for execution permissions
    - Handles script arguments

### Error Handling
An error module is defined in `lib/pennos-errno.h` and `lib/pennos-errno.c`. This module simply defines the set of error codes used throughout our code, and `P_ERRNO` is the variable that tracks the current error code set at any point in the program. `shell/builtins.h` and `shell/builtins.c` define and implement the `u_perror` function, which is used to display user-level error messages to stdout.


## Code Layout
- `bin/`
    - `pennfat` (executable)
    - `pennos` (executable)
- `doc/`
    - `README.md`
    - `companion_doc.pdf`
- `log/`
    - *generated log files*
- `src/` 
    - `fs/`
        - `fat_routines.c`
        - `fat_routines.h`
        - `fs_helpers.c`
        - `fs_helpers.h`
        - `fs_kfuncs.c`
        - `fs_kfuncs.h`
        - `fs_syscalls.c`
        - `fs_syscalls.h`
    - `kernel/`
        - `kern_pcb.c`
        - `kern_pcb.h`
        - `kern_sys_calls.c`
        - `kern_sys_calls.h`
        - `logger.c`
        - `logger.h`
        - `scheduler.c`
        - `scheduler.h`
        - `signal.c`
        - `signal.h`
        - `stress.c`
        - `stress.h`
    - `lib/`
        - `pennos-errno.c`
        - `pennos-errno.h`
        - `spthread.c`
        - `spthread.h`
        - `Vec.c`
        - `Vec.h`
    - `shell/`
        - `builtins.c`
        - `builtins.h`
        - `Job.h`
        - `parser.c`
        - `parser.h`
        - `shell_built_ins.c`
        - `shell_built_ins.h`
        - `shell.c`
        - `shell.h`
    - `pennfat.c`
    - `pennos.c`
- `tests/`
    - `sched-demo.c`
- `.gitignore`
- `Makefile`

## Code Description and Design Justifications

### PennFAT Filesystem

- **fat_routines**
    - `mkfs`: 
        - *Inputs*: filename, number of blocks, and size of each block
        - *Output*: 0 on success, -1 on failure
        - *Description*: Makes a filesystem. Uses the inputs to calculate the size of the FAT region, data region, and the filesystem. Then makes a system call with `open()` to open the filename and uses `ftruncate()` to extend the filesystem's size. A combination of `calloc`, `lseek`, and `write` are used to allocate space for both the fat region and root directory and write their contents to the filesystem. 
    - `mount`:
        - *Input*: filename `fs_name`
        - *Output*: 0 on success, -1 on error
        - *Description*: Mounts the specified filesystem. Opens the filesystem and stores the file descriptor returned by `open()` in `fs_fd`. Most notably, `mount` will call `mmap()` to map the FAT region into memory, initialize the system-wide file descriptor table, and initialize the other global variables `block_size`, `num_fat_blocks`, `fat_size`, `fat`, `is_mounted`, and `MAX_FDS`.
    - `unmount`:
        - *Input*: N/A
        - *Output*: 0 on success, -1 on error
        - *Description*: Unmounts the currently mounted filesystem. Uses `munmap` to unmap the fat region, closes `fs_fd`, and resets the globals.
    - `cat`:
        - *Input*: Void pointer to a list of arguments
        - *Output*: Void pointer
        - *Description*: Concatenates and displays files. First, scans the list of arguments and opens the output file with `k_open`. If the output flag is -w, then we overwrite the output file; if the output flag is -a, then we append to the output file. If no output redirection is supplied, then we write to stdout. If there is at least one input file, we process and write each input file to the output file using `k_open`; otherwise, we simply read from stdin and write to the output file.
    - `ls`:
        - *Inputs*: Void pointer to a list of arguments.
        - *Output*: Void pointer
        - *Description*: Lists all files in the root directory. Keeps track of a `current_block` that starts at 1, denoting the root directory. Starting at the first block, use read every directory entry and print its content to stdout. We keep updating `current_block` to the next block and repeat the process until the fat chain ends. 
    - `touch`:
        - *Inputs*: Void pointer to a list of arguments.
        - *Output*: Void pointer
        - *Description*: Creates files or updates timestamps. For each file supplied as an argument, we first determine if the file already exists in the root directory. If the file exists, update its timestamp. Otherwise, add its file entry to the root directory. 
    - `mv`: 
        - *Inputs*: Void pointer to a list of arguments.
        - *Output*: Void pointer
        - *Description*: Renames a source file to a destination file. If the source and destination files have the same name, then return. If the source file is not in the root directory, then we return from the routine and set the error code. Next, we check if the destination file exists. If it exists, then we mark the destination file entry as deleted, only if it not currently in use by any other fd. Lastly, rename the source entry's filename and write the change to the root directory of the filesystem.
    - `cp`:
        - *Inputs*: Void pointer to a list of arguments.
        - *Output*: Void pointer
        - *Description*: Copies a source file to a destination. If the command is of the form `cp -h SOURCE DEST`, then we open `SOURCE` using `open()` and `DEST` with `k_open()`. While the bytes remaining in `SOURCE` is greater than zero, we use `read()` to read a certain number of bytes from `SOURCE` and use `k_write()` to write the same number of bytes to `DEST`. The buffer size we choose does not exceed the `block_size` of the currently mounted filesystem. The logic follows similarly for `cp SOURCE -h DEST` and `cp SOURCE DEST`. 
    - `rm`:
        - *Inputs*: Void pointer to a list of arguments.
        - *Output*: Void pointer
        - *Description*: Removes files. For each file supplied as an argument, we mark the file entry as deleted and write the change to the root directory of the filesystem. Before we can mark a file entry as deleted, we must first check that it exists using the `find_file()` helper function, which returns the absolute offset of where the file entry is located in the filesystem. We use this absolute offset as a parameter in `lseek()` and then use `write()` to commit the change.
    - `chmod`:
        - *Inputs*: Void pointer to a list of arguments.
        - *Output*: Void pointer
        - *Description*: Changes file permissions. Parses the permission string (e.g., +rw, -x) to determine which permissions to add or remove. Locates the file's directory entry, updates the permission byte according to the requested changes, and writes the updated entry back to disk. Handles error cases such as non-existent files or invalid permission specifications appropriately.
    - `cmpctdir`:
        - *Inputs*: Void pointer to a list of arguments.
        - *Output*: Void pointer
        - *Description*: Compacts the directory structure by removing gaps left by deleted files. Traverses the root directory blocks, identifies deleted entries (marked with 1 or 2 in the first byte), and rearranges valid entries to eliminate gaps. Ensures all directory entries remain in a contiguous sequence, which improves directory traversal performance. This extra credit feature optimizes filesystem storage by reducing fragmentation in the directory structure.
- **fs_helpers**
    - `init_fd_table`: 
        - *Inputs*: A pointer to the system-wide fd table
        - *Output*: N/A
        - *Description*: Initializes all entries in the file descriptor table. Note that the first three file descriptors are reserved for stdin, stdout, and stderr, respectively. The other file descriptor entries' fields will be flushed and set to not in use.
    - `get_free_fd`:
        - *Inputs*: A pointer to the system-wide fd table
        - *Output*: The index to the first free fd; -1 if none available.
        - *Description*: Used in `k_open()`. Iterates through the file descriptor array until we find the first un-used fd and return its index. 
    - `increment_fd_ref_count`:
        - *Input*: The fd number
        - *Output*: The new reference count or -1 on error.
        - *Description*: Used in shell. Increments the reference count of a file descriptor that is in use and returns the fd's reference count.
    - `decrement_fd_ref_count`:
        - *Inputs*: The fd number
        - *Output*: The new reference count or -1 on error.
        - *Description*: Used in shell. Decrements the reference count of a file descriptor that is in use and returns the fd's reference count.
    - `has_executable_permission`:
        - *Inputs*: The fd number
        - *Output*: 1 if the file has executable permissions, 0 if it doesn't, -1 if an error occurred.
        - *Description*: Checks if a file has executable permissions. Checks if the file entry exists and returns 1 if the file has executable permissions; 0 otherwise.
    - `allocate_block`:
        - *Inputs*: N/A
        - *Output*: The block number of the allocated block; 0 if there are no free blocks available.
        - *Description*: Returns the first free block in the FAT table and marks it as used. If there are no free blocks, we try compacting the directory and try again. Otherwise, return 0.
    - `find_file`:
        - *Inputs*: The filename to search for; the output parameter for the file entry
        - *Output*: Absolute offset of the file in the filesystem.
        - *Description*: Searches for the file entry with the filename supplied as an argument and points the output parameter to this file entry if found. Follows the FAT chain for the root directory. For each block, we process each file entry in the current block and check the current file entry's filename. If we reach the end of a block, we move to the next block as permitted by the FAT chain, then continue the process until we find the desired file.
    -  `add_file_entry`
        - *Inputs*: filename, size, first block, type, and permissions
        - *Output*: Offset of the file entry that was added in the filesystem
        - *Description*: Adds a new file entry to the root directory. First checks if the file already exists by calling `find_file()`. Then searches through the root directory blocks for a free slot (either an empty entry or a deleted entry marked with 1). If a free slot is found, it initializes a new directory entry with the provided parameters, sets the modification time to the current time, and writes the entry to disk. If no free slot is found in existing blocks, it allocates a new block, links it to the directory chain, and adds the entry there.
    - `mark_entry_as_deleted`
        - *Inputs*: A pointer to the file entry; the absolute offset of the file entry's position
        - *Output*: 0 on success, -1 on error
        - *Description*: Marks a file entry entry as deleted, writes the changes to the root directory, and frees the relevant blocks. Follows the FAT chain, starting at the file entry's first block, and sets each block as free. Mark the file entry as deleted by setting the first slot of the filename as 0. Move the filesystem's pointer to the absolute offset using `lseek()` and use `write()` to write the changes to the filesystem.
    - `copy_host_to_pennfat`
        - *Inputs*: A pointer to the host filename, a pointer to the pennfat filename
        - *Output*: 0 on success, -1 on error
        - *Description*: Used in the `cp` routine. Copies data from host OS file to the PennFAT file. Uses `open()` to open the host filename for reading and `k_open()` to open the pennfat filename. While the bytes remaining in the host filename is greater than 0, we use `read()` to read a certain number of bytes from the host filename and use `k_write()` to write the same number of bytes to the pennfat filename. Properly handles errors and ensures resource cleanup.
    - `copy_pennfat_to_host`
        - *Inputs*: Source filename in the PennFAT filesystem and the destination path on the host OS
        - *Output*: 0 on success, -1 on error
        - *Description*: Copies a file from the PennFAT filesystem to the host OS. Opens the source file in PennFAT using `k_open()` and creates the destination file on the host filesystem using standard `open()` with appropriate flags for creation and truncation. Allocates a buffer for data transfer and copies the file content in chunks, using `k_read()` to read from PennFAT and standard `write()` to write to the host file. Properly handles errors and ensures resource cleanup.
    - `copy_source_to_dest`
        - *Inputs*: Source and destination filenames, both within the PennFAT filesystem
        - *Output*: 0 on success, -1 on error
        - *Description*: Copies a file within the PennFAT filesystem. Opens the source file for reading and the destination file for writing using `k_open()`. Transfers data in chunks using a buffer, reading from the source with `k_read()` and writing to the destination with `k_write()`. This function is simpler than the cross-filesystem copies as it doesn't need to manage different file system interfaces. Ensures proper error handling and resource cleanup throughout the operation.
- **fs_kfuncs**
    - `k_open`: 
        - *Inputs*: A pointer to the filename, and the read mode (F_READ, F_WRITE, and F_APPEND)
        - *Output*: A fd on success, -1 on error. 
        - *Description*: Opens a filename and returns the associated fd. First ensures that there is a free, un-used fd from the fd table using `get_free_fd()`. If the file doesn't exist and the mode is not F_WRITE, then we set the error code and return -1. If the file doesn't exist but the mode is F_WRITE, we allocate the first available block using `allocate_block()`, add the file entry to the root directory using `add_file_entry()`, and initializes the fd entry in the fd table.
    - `k_read`:
        - *Inputs*: The file descriptor of the open file, the buffer to store the read data, and the number of bytes
        - *Output*: The number of bytes read on success, -1 on error
        - *Description*: Reads data from an open file. Validates the file descriptor and buffer, then determines how many bytes can actually be read based on the current file position and size. Navigates to the correct block in the file's chain by following the FAT entries, and positions at the appropriate offset within that block. Reads data in chunks, potentially spanning multiple blocks if necessary. Updates the file position after reading and handles edge cases like EOF and block boundaries. Returns the total number of bytes read or appropriate error codes. 
    - `k_write`:
        - *Inputs*: The file descriptor, a pointer to the data buffer, and the number of bytes to write
        - *Output*: The number of bytes written on success, -1 on error
        - *Description*: Writes data to an open file. Validates the file descriptor and input buffer, then prepares for writing by calculating the current block and offset. If the file doesn't have a first block yet, it allocates one. Navigates to the appropriate position in the file's block chain, allocating new blocks as necessary when crossing block boundaries. Uses a read-modify-write approach for partial block writes to preserve existing data. Updates the file size if the write extends beyond the current end of file, and updates the directory entry accordingly. Returns the number of bytes successfully written.
    - `k_close`:
        - *Inputs*: The file descriptor to close
        - *Output*: 0 on success, -1 on error
        - *Description*: Closes an open file and releases its file descriptor. Validates that the file descriptor is in use, then ensures any pending changes are written to disk by updating the directory entry with the current file size and modification time. Marks the file descriptor as not in use, making it available for reuse by future `k_open` calls. Returns 0 on successful closure or an appropriate error code if the file descriptor is invalid.
    - `k_unlink`:
        - *Inputs*: The name of the file to remove
        - *Output*: 0 on success, -1 on error
        - *Description*: Removes a file from the filesystem. Verifies the filename is valid and the filesystem is mounted. Checks if the file is currently open by examining the file descriptor table, and returns an error if any process is using the file. Locates the file's directory entry, marks it as deleted by setting its first byte to 1, and frees all blocks in the file's chain by traversing the FAT and setting each block to `FAT_FREE`. Returns 0 on successful deletion or an appropriate error code.
    - `k_lseek`:
        - *Inputs*: The file descriptor, the offset value, and the reference position (SEEK_SET, SEEK_CUR, or SEEK_END)
        - *Output*: The new file position on success, -1 on error
        - *Description*: Repositions the file offset within an open file. Validates the file descriptor and calculates the new position based on the whence parameter: `SEEK_SET` positions relative to the beginning of the file, `SEEK_CUR` relative to the current position, and `SEEK_END` relative to the end of the file. Verifies the resulting position is valid (not negative), updates the file descriptor's position field, and returns the new position. Returns an appropriate error code if the file descriptor is invalid or the resulting position would be negative.
    - `k_ls`:
        - *Inputs*: The name of a file to list, or NULL to list all files in the current directory
        - *Output*: 0 on success, -1 on error
        - *Description*: Lists files or file information in the current directory. First checks if the filesystem is mounted. If a specific filename is provided, it locates that file's directory entry using `find_file()` and displays its detailed information. If NULL is provided, it traverses the entire root directory structure, following the FAT chain if necessary, and displays information about each valid file entry (skipping deleted entries). For each file, it formats information including block number, permissions, size, timestamp, and name, then writes this information to standard output using `k_write()`. Returns 0 on success or an appropriate error code.
- **fs_syscalls**
    - These functions are simply wrappers around the kernel functions.

### Kernel
- **kern_pcb**
    - `free_pcb`:
        - *Inputs*: A pointer to the pcb to be created
        - *Output*: Void
        - *Description*: Frees the heap-allocated fields of the pcb struct. Then it finally frees the struct itself.
    - `create_pcb`
        - *Inputs*: Its own pid, its parent pid, priority, and input file descriptor, and an output file descriptor
        - *Output*: A pointer to the pcb struct that was created.
        - *Description*: Allocates and initializes a new PCB. It sets up the PCB with the provided parameters and initializes other fields with default values: process state 'R' (running), empty child vector, all signals to false, sleeping status to false, and wake time to -1. It returns the created PCB pointer or NULL if memory allocation fails.
    - `remove_child_in_parent`:
        - *Inputs*: A pointer to the parent's pcb struct, a pointer to the child's pcb struct
        - *Output*: Void
        - *Description*: Removes a child PCB from its parent's child vector. It searches through the parent's child vector for a PCB with matching PID and removes it without freeing the memory (using `vec_erase_no_deletor`). This allows the child to continue existing independently of its parent.
    - `k_proc_create`
        - *Inputs*: A pointer to the parent's pcb struct, a priority
        - *Output*: Pointer to the newly created child PCB, or NULL on error
        - *Description*: Creates a new process at the kernel level. For the init process (when parent is NULL), it creates a special PCB with PID 1. For other processes, it creates a child with the next available PID, inherits file descriptors from the parent, and adds the child to the parent's child vector. It also adds the new PCB to the appropriate scheduler queue and to the global PCB list.
    - `k_proc_cleanup`:
        - *Inputs*: Pointer to the PCB to clean up
        - *Output*: None
        - *Description*: Cleans up resources associated with a terminated process. It removes the process from its parent's child list, handles any children by reassigning them to the init process (PID 1), logs orphan events for these reassigned children, removes the process from all scheduler queues, and finally frees the PCB's memory.
- **kern_sys_calls**
    - `determine_index_in_queue`:
        - *Inputs*: Pointer to a vector queue, process ID to search for
        - *Output*: Integer index of the PCB in the queue, or -1 if not found
        - *Description*: Searches through the given queue to find a PCB with the specified PID. It iterates through the queue elements, checks each PCB's PID, and returns the index if found or -1 if not found.
    - `move_pcb_correct_queue`:
        - *Inputs*: Previous priority level (0, 1, or 2), new priority level (0, 1, or 2), pointer to the PCB being moved
        - *Output*: None
        - *Description*: Moves a PCB from its previous priority queue to a new one. It determines the appropriate queues based on priority levels, removes the PCB from the previous queue (if present), and adds it to the new queue.
     - `delete_from_queue`:
        - *Inputs*: Queue identifier (0, 1, or 2 for priority queues), process ID to remove
        - *Output*: none
        - *Description*: Removes a PCB with the specified PID from one of the priority queues. It selects the appropriate queue based on queue_id, finds the PCB using determine_index_in_queue, and removes it using vec_erase_no_deletor if found.
    - `init_func`:
        - *Inputs*: Void pointer 
        - *Output*: NULL
        - *Description*: The function executed by the init process. It spawns the shell process and enters an infinite loop to continuously wait for and reap zombie children. This ensures orphaned processes are properly cleaned up.
    - `s_spawn_init`:
        - *Inputs*: None
        - *Output*: The PID of the created init process, or -1 on error
        - *Description*: Creates the init process that serves as the ancestor of all processes in the system. It calls `k_proc_create` with NULL parent to create the init PCB, creates a thread to run init_func, sets up the cmd_str and thread_handle, and returns the PID.
    - `s_spawn`:
        - *Inputs*: Function pointer to be executed by the child, null-terminated array of arguments, input file descriptor, output file descriptor.
        - *Output*: The PID of the created child process, or -1 on error
        - *Description*: Creates a child process to execute the specified function. It determines the appropriate priority (0 for shell_main, 1 for others), creates a PCB using k_proc_create, creates a thread to run the function, sets the command string and file descriptors, logs the creation event, and returns the PID.
    - `s_waitpid`:
        - *Inputs*: PID of the child to wait for (-1 for any child), pointer to store the child's status, nohang
        - *Output*: The PID of the child that changed state, 0 if nohang and no child exited, or -1 on error
        - *Description*: Waits for a child process to change state. First checks the zombie queue for terminated children, returns immediately with 0 if nohang is true and no child has exited, or blocks the parent and continuously checks the zombie queue until a matching child is found.
    - `s_kill`:
        - *Inputs*: PID of the target process, signal number to send (0=P_SIGSTOP, 1=P_SIGCONT, 2=P_SIGTERM)
        - *Output*: 0 on success, -1 if the PID is not found
        - *Description*: Sends a signal to a specific process. It finds the PCB with the specified PID, sets the appropriate signal flag, logs the signal event, and returns 0 on success or -1 if the process is not found.
- **logger**
    - `log_scheduling_event`:
        - *Inputs*: Process ID being scheduled, priority queue number, string containing process name
        - *Output*: none
        - *Description*: Logs a scheduling event when a process is selected to run. Creates a formatted string with timestamp, schedule event type, PID, queue number, and process name, then writes it to the log file.
    - `log_generic_event`
        - *Inputs*: Character code for event type (C=CREATE, S=SIGNALED, etc.), process ID, process priority value, process name string
        - *Output*: None
        - *Description*: Logs various process events such as creation, termination, or state changes. Converts the event code to a descriptive string, formats the log entry with timestamp and process info, and writes to the log file.
     - `log_nice_event`: 
        - *Inputs*: pid, previous priority, new priority, process name string
        - *Output*: None
        - *Description*: Logs when a process's priority (nice value) is changed. Creates a formatted log entry with timestamp, NICE event type, PID, old and new priority values, and process name.
- **scheduler**
    - `initialize_scheduler_queues`:
        - *Inputs*: none
        - *Output*: none
        - *Description*: Initializes all scheduler queues (priority queues, zombie queue, sleep queue, etc.) using vec_new. Most queues are created without destructors to prevent double-freeing when PennOS exits.
    - `free_scheduler_queues`
        - *Inputs*: none
        - *Output*: none
        - *Description*: Properly cleans up all scheduler queues by calling vec_destroy on each one. Used during system shutdown to release allocated memory.
    - `generate_next_priority`:
        - *Inputs*: None
        - *Output*: integer priority level; -1 if queues are empty
        - *Description*: Determines which priority queue to service next based on the relative scheduling algorithm. Uses a deterministic pattern that ensures priority 0 processes run 1.5x more often than priority 1, which run 1.5x more often than priority 2.
    - `get_next_pcb`:
        - *Inputs*: Priority level
        - *Output*: Pointer to the next PCB to run, or NULL if the specified queue is empty
        - *Description*: Retrieves and removes the next PCB from the specified priority queue. Returns NULL if priority is -1 or if the corresponding priority queue is empty.
    - `put_pcb_into_correct_queue`
        - *Inputs*: Pointer to the PCB to insert
        - *Output*: None
        - *Description*: Places a PCB into the appropriate queue based on its state and priority. Running processes go to priority queues, zombies to the zombie queue, and blocked/stopped processes to the sleep queue.
    - `delete_process_from_particular_queue`:
        - *Inputs*: pointer to the PCB to remove, pointer to the queue to search
        - *Output*: none
        - *Description*: Removes a specific PCB from a given queue if present. Searches the queue for the PCB with matching PID and removes it without freeing its memory.
    - `delete_process_from_all_queues`:
        - *Inputs*: Pointer to the PCB to remove
        - *Output*: None
        - *Description*: Removes a PCB from all scheduler queues. Calls delete_process_from_particular_queue for each queue type and the global PCB list, ensuring the process is completely removed from the scheduling system.
    - `child_in_zombie_queue`:
        - *Inputs*: A pointer to the parent PCB
        - *Output*: true if a child of the parent is in the zombie queue, false otherwise
        - *Description*: Checks if a child of the given parent process is in the zombie queue. This function iterates through the zombie queue to determine if any process in the queue has the given parent process as its parent.
    - `child_with_changed_process_status`:
        - *Inputs*: A pointer to the parent PCB
        - *Output*: true if a child of the parent is in the zombie queue, false otherwise
        - *Description*: Checks if a child of the given parent process has a changed process status. This function iterates through the current PCBs to determine if any child of the given parent process has a non-zero process status, indicating a change.
    - `alarm_handler`
        - *Inputs*: signum, the signal number
        - *Output*: none
        - *Description*: Handles the alarm signal. This function is triggered when the alarm signal is received. It increments the global tick counter, which is used for scheduling and timing purposes.
    - `handle_signal`
        - *Inputs*: a pointer to the pcb struct, signal number
        - *Output*: none
        - *Description*: Handles a signal for a given process.
    - `scheduler`
        - *Inputs*: none
        - *Output*: none
        - *Description*: The main scheduler function for PennOS. This function manages process scheduling, signal handling, and timer-based preemption. It ensures that processes are executed based on their priority and handles signals for both the currently running process and other processes.
    - `s_shutdown_pennos`
        - *Inputs*: none
        - *Output*: none
        - *Description*: Shuts down the PennOS scheduler. This function sets the scheduling_done flag to true, signaling the scheduler to terminate its loop and shut down.

### Shell
- **builtins**
    - `u_perror`: 
        - *Inputs*: Error message string
        - *Output*: None
        - *Description*: Custom error reporting function similar to perror(). Maps P_ERRNO values to descriptive error messages, formats them with the input message, and outputs to stderr.
- **shell_built_ins**
    - `u_cat`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: User-level wrapper for the cat command. Calls the filesystem's cat() function with the provided arguments.
    - `u_sleep`
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Sleeps for a specified number of seconds. Converts the argument to seconds, calculates the equivalent number of clock ticks, calls s_sleep(), and exits.
    - `u_busy`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Busy-waits indefinitely in an infinite loop. Can only be interrupted by signals.
    - `u_echo`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Echoes the input string back to stdout. (Implementation incomplete in the provided code)
    - `u_ls`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Lists files in the current directory. Calls the filesystem's ls() function with the provided arguments.
    - `u_chmod`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Changes file permissions. (Implementation incomplete in the provided code).
    - `u_touch`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Creates empty files or updates timestamps of existing files. Calls the filesystem's touch() function.
    - `u_mv`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Renames files. Calls the filesystem's mv() function with the provided arguments.
    - `u_cp`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Copies files. Calls the filesystem's cp() function with the provided arguments.
    - `u_rm`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Removes files. Calls the filesystem's rm() function with the provided arguments.
    - `u_ps`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Lists all processes running in PennOS. Displays a formatted table with PID, PPID, priority, status, and command name for each process.
    - `u_kill`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Sends signals to processes. Interprets signal type (-term, -stop, -cont) and sends the appropriate signal to specified PIDs using s_kill().
    - `get_associated_ufunc`:
        - *Inputs*: String containing function name
        - *Output*: Function pointer to the corresponding "u_" function
        - *Description*: Helper function that maps command names to their corresponding user-level function implementations. Returns NULL if no match is found.
    - `u_nice`:
        - *Inputs*: Pointer to command arguments.
        - *Output*: NULL
        - *Description*: Spawns a new process with a specified priority. Parses priority level and command, gets the function pointer using get_associated_ufunc, spawns the process with s_spawn, and sets its priority with s_nice.
    - `u_nice_pid`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Adjusts the priority of an existing process. Parses priority and PID arguments, then calls s_nice to change the process's priority.
    - `u_man`:
        - *Inputs*: Pointer to command arguments (unused)
        - *Output*: none
        - *Description*: Displays a help page listing all available commands with their descriptions. Writes a predefined string to stderr.
    - `u_bg`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Resumes a stopped job in the background. (Implementation incomplete in the provided code)
    - `u_fg`:
        - *Inputs*: Pointer to command arguments
        - *Output*:
        - *Description*: Brings a job to the foreground. (Implementation incomplete in the provided code)
    - `u_jobs`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Lists all background jobs. (Implementation incomplete in the provided code)
    - `u_logout`:
        - *Inputs*: Pointer to command arguments (unused)
        - *Output*: none
        - *Description*: Exits the shell and shuts down PennOS by calling the shutdown_pennos() function.
    - `u_zombify`:
        - *Inputs*: Pointer to command arguments (unused)
        - *Output*: none
        - *Description*: Creates a child process that immediately exits (becoming a zombie) while the parent enters an infinite loop. Used to test zombie process handling.
    - `u_orphanify`:
        - *Inputs*: Pointer to command arguments
        - *Output*: none
        - *Description*: Creates a child process that enters an infinite loop, then parent exits immediately. Used to test orphan process handling by init.
- **shell**
    - `shell`:
        - *Inputs*: Void pointer
        - *Output*: 0
        - *Description*: Main shell function that provides the command interface. Initializes the job list, sets up signal handlers, enters a loop to read and process commands, manages background and foreground jobs, and finally cleans up resources on exit.

## General Comments
- N/A